function [vert, connect_mat] = createRoadmap(polygons,limits,waypoints,sta)
% createRoadmap: Given a polygonal environment returns a roadmap covering
% Q_free. Can also input initial and goal points to include in roadmap.
%
%   [vert, connect_mat, G] = createRoadmap(polygonstxt,limits,start_goal)
%   returns the Nodes, Connectivity Matrix and MATLAB Graph Object
%   representing the roadmap.
%
%   INPUTS
%      polygonstxt     Each line in the file contains the vertices of
%                       one polygonal obstacle: v1x, v1y, v2x, v2y,
%                       etc. The vertices are given in counterclockwise
%                       order. To make it easy to import in MATLAB,
%                       each line contains 16 entries corresponding to
%                       (up to) 8 vertices. If an obstacle has fewer
%                       vertices, unused entries in the line will
%                       contain the value zero.
%      limits           Boundary of the polygons, given in [xmin ymin xmax ymax]
%      start_goal       Optional input, for [start point; goal point] (2x2)
%
%   OUTPUTS
%       vert            N-by-2 vector of nodes, with each row being [x y]
%       connect_mat     N-by-N connectivity matrix, diagonal is
%                       ignored (all 0) because self loops are meaningless
%                       in this context. The values (if not 0) are the edge
%                       weights based on distance.
%       G               MATLAB object, weighted graph.
%
%   Cornell University
%   Autonomous Mobile Robots
%   Homework 8
%   SHI, KOWIN

[m,~] = size(polygons);

vert = [];
edges = [];

for i=1:m
    x = polygons(i,1:2:end)';
    y = polygons(i,2:2:end)';
    for j=1:4
        currx = x(j);
        curry = y(j);
        if currx>limits(1) && curry>limits(2) && currx<limits(3) && curry<limits(4)
            vert = [vert;[currx curry]];
        end
    end
end

vert = [vert; waypoints];

[g,~] = size(vert);
connect_mat = zeros(g,g);

for j=1:g-1
    currvert = vert(j,1:2);
    for z=j+1:g
        endvert = vert(z,1:2);
        desw = 0;
        
        for k=1:m
            edgevec = edges{k};
            [n,~]=size(edgevec);
            if ismember([currvert endvert],edgevec)
                desw = 1;
                break
            end
            for l=1:n
                [isect,~,~,ua]= intersectPoint(currvert(1),currvert(2),...
                    endvert(1),endvert(2),edgevec(l,1),edgevec(l,2),...
                    edgevec(l,3),edgevec(l,4));
                if isect && ua>1e-7 && abs(ua-1)>1e-7
                    desw = 1;
                    break
                end
            end
            if desw==1
                break
            end
        end
        if desw==0
            dist = norm(currvert-endvert);
            connect_mat(j,z)=dist;
            connect_mat(z,j)=dist;
        end
    end
end

end